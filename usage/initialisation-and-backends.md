# Initialisation & Backends

{% hint style="warning" %}
Before using FMTC, especially to bulk download, ensure you comply with the appropriate restrictions and terms of service set by your tile server. Failure to do so may lead to any punishment, at the tile server's discretion.

This library and/or the creator(s) are not responsible for any violations you make using this package.

***

Some common tile servers' ToS are listed below:

* [OpenStreetMap](https://operations.osmfoundation.org/policies/tiles)
* [Mapbox](https://www.mapbox.com/legal/tos)
* [Thunderforest](https://www.thunderforest.com/terms/)
* [Stadia Maps](https://stadiamaps.com/terms-of-service/)

For testing purposes, check out the testing tile server included in the FMTC project: [#testing-your-application](../bulk-downloading/introduction.md#testing-your-application "mention").
{% endhint %}

## Backends

FMTC allows attachment of any custom storage mechanism, through an `FMTCBackend`. This allows users to pick their favourite database engine, or conduct in-memory testing.

Only one backend is built-into FMTC: the `FMTCObjectBoxBackend`. This backend uses the [ObjectBox library](https://pub.dev/packages/objectbox) to store data.

## Initialisation

FMTC requires initialisation before it can be used. This is to allow FMTC and the specified backend to start necessary background threads, load required resources, and connect to databases. FMTC and backends work using singletons, so after the initial initialisation, it should not be required again.

Initialisation is performed through a backend, which exposes an `initialise` method.

This should be called before any other FMTC or backend methods are used, and so it is usually placed just before `runApp`, in the `main` method. This shouldn't have any significant affect on application startup time.

{% hint style="warning" %}
If initialising in the `main` method before `runApp` is called, ensure you also call `WidgetsFlutterBinding.ensureInitialised()` prior to the backend initialisation.
{% endhint %}

<pre class="language-dart"><code class="lang-dart">import 'package:flutter/widgets.dart';
import 'package:flutter_map_tile_caching/flutter_map_tile_caching.dart';

Future&#x3C;void> main() async {
    WidgetsFlutterBinding.ensureInitialized();   
<strong>    await FMTCObjectBoxBackend().initialise(...);
</strong>    
    // Run your app and do all of that other stuff
}
</code></pre>

{% hint style="danger" %}
Do not call any other FMTC methods before initialisation. Doing so will cause a `RootUnavailable` error to be thrown.
{% endhint %}

### In A Seperate `Isolate`

{% hint style="warning" %}
Avoid using FMTC in a seperate thread/`Isolate`. FMTC backends already make extensive use of multi-threading to improve performance.

If it is essential to use FMTC in a seperate thread, ensure that the initialisation is called in the thread where it is used. Be cautious of using FMTC across multiple threads simultaneously, as backends may not properly support this, and unexpected behaviours may occur.
{% endhint %}

### Exception Handling

The `initialise` method takes a callback that will be invoked with an `Object` and a `StackTrace` when an exception (or error) occurs in the backend.

{% hint style="info" %}
The exception handler is not called when the internal error was of type `FMTCBackendError`: it was created by FMTC. These errors are always thrown with the modified `StackTrace` (see below), because they should be resolved by the user, and are unlikely to indicate an issue with the backend (potentially unlike other errors).
{% endhint %}

Because the backend is highly asynchronous, split across threads and communicated with `Stream`s, any errors that occur cannot be thrown at their original point of invocation. For example, if the `StoreManagement.create()` method is called, and the backend throws an error whilst processing that operation, the `create` method will not throw. Instead, the exception handler will be called.

The `Object` represents the original exception thrown, whilst the `StackTrace` is slightly modified to give an indication of where the failure occured internally.

Additionally, the callback also takes an `initialisationFailure` flag, which indicates whether the error occured during initialisation. If it is `true`, then the error was fatal and will have killed the backend. Otherwise, the backend should still recieve and respond to future operations.

For example, if the database is corrupted on startup, and `FMTCObjectBoxBackend` is in use, then the handler will be invoked with the `StorageException` generated by ObjectBox, and `initialisationFailure` set `true`.

For further info, see:

<mark style="color:purple;background-color:orange;">link</mark>
